
/* Theory is easy
but practicle implementation requires mathematics */

* {
    margin: 0px;
    padding: 0px;
    box-sizing: border-box;
}
html,
body {
    width: 100vw;
    height: 100vh;
}

.wrapper {
    border: 1px solid black;
    width: 90%;
    max-width: 1536px;
    height: 100px;

    margin-inline: auto;
    position: relative;
    margin-top: 5rem;

    overflow: hidden;
}

@keyframes scroll-left {
    to {
        left: -200px;
    }
}

.item {
    width: 12.5rem;
    height: 6.25rem;
    background-color: red;
    border-radius: 6px;
    position: absolute;

    left: 10px;

    left: 100%;

    animation-name: scroll-left;

    /* let's make it slow so that we can clearly see all the things */
    animation-duration: 30s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
}

/* Here where we need to do our mathematics */
/* In css we use clac() to do mathematics  */

/* first clac(animation-duration / total no. of div) */
.item-1 { animation-delay:  calc( 30s / 8 * (8 - 1) * -1 ) ;}  /* -26.25 */
.item-2 { animation-delay:  calc( 30s / 8 * (8 - 2) * -1 ) ;}  /* -22.5  */
.item-3 { animation-delay:  calc( 30s / 8 * (8 - 3) * -1 ) ;}
.item-4 { animation-delay:  calc( 30s / 8 * (8 - 4) * -1 ) ;}
.item-5 { animation-delay:  calc( 30s / 8 * (8 - 5) * -1 ) ;}
.item-6 { animation-delay:  calc( 30s / 8 * (8 - 6) * -1 ) ;}
.item-7 { animation-delay:  calc( 30s / 8 * (8 - 7) * -1 ) ;}  /* -3.75  */
.item-8 { animation-delay:  calc( 30s / 8 * (8 - 8) * -1 ) ;}  /* 0     */

 

/* 

explain 
Assume the total time to perform anuimation is 30s ( To complete one loop it takes 30s)
and we have 8 items to animate. so, each item will take (30 / 8)s  time

now we want sequantial movement of all elements. so, we add unique delay for each item

we make the value negetive by multiplying it withh -1 
if animation-delay property has negetive value that means some part of animation already completed or you can say already running before you visit the webpage. and after that much animation it will continue 

so this is the logic.

Recap :
Duration : 30 / n
Delay : n - x
negative : -1

where, n = total no. of elements
       x = element index number 

*/