/* Theory is easy
but practicle implementation requires mathematics */

* {
    margin: 0px;
    padding: 0px;
    box-sizing: border-box;
}

.wrapper {
    /* border: 1px solid black; */
    width: 90%;
    max-width: 1536px;
    height: 100px;

    margin-inline: auto;
    position: relative;
    margin-top: 5rem;
    padding-top: 10px;

    overflow: hidden;



    /* mask-image property ,
    suppose an "element" wtih star shape
    and we have 'image' 
    we want to set the 'image' as background-image of "element" then we use mask-image property */

    /* here we use it to create fade-out effect */
    /* mk : simple terms we set the bacground of wrapper */
 

    /* check learn.md */
    mask-image: linear-gradient(to right, rgba(0,0,0,0),rgba(0,0,0,1) 20%, rgba(0,0,0,1) 80%, rgba(0,0,0,0));
}
@keyframes scroll-left {
    to {
        left: -200px;
    }
}

.item {
    width: 150px;
    height: 80px;
    background-color: red;
    border-radius: 6px;
    position: absolute;


    /* left : 100% (it is setted accordting to viewport)
    when i resize the page the 100% will change relative the viewport 
    and the width of item is constant
    so let's make it constant also. */
    left: max(calc(200px * 8), 100%);

    /* Somethimes animation not work well with large screen that's why we need to use max() function */
    /* Max function gives an argument
    at any time which is most biggest that will be applied */


    /* mk : for small devices pixels are also becomes small 
    we can put a constant value of 200 px and it will work. */

    animation-name: scroll-left;

    /* let's make it slow so that we can clearly see all the things */
    animation-duration: 30s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
}

/* Here where we need to do our mathematics */
/* In css we use clac() to do mathematics  */

/* first clac(animation-duration / total no. of div) */

.item-1 {
    animation-delay: calc(30s / 8 * (8 - 1) * -1);
    background-color: black;
} /* -26.25 */
.item-2 {
    animation-delay: calc(30s / 8 * (8 - 2) * -1);
    background-color: red;
} /* -22.5  */
.item-3 {
    animation-delay: calc(30s / 8 * (8 - 3) * -1);
    background-color: yellow;
}
.item-4 {
    animation-delay: calc(30s / 8 * (8 - 4) * -1);
    background-color: green;
}
.item-5 {
    animation-delay: calc(30s / 8 * (8 - 5) * -1);
    background-color: blue;
}
.item-6 {
    animation-delay: calc(30s / 8 * (8 - 6) * -1);
    background-color: orange;
}
.item-7 {
    animation-delay: calc(30s / 8 * (8 - 7) * -1);
    background-color: purple;
} /* -3.75  */
.item-8 {
    animation-delay: calc(30s / 8 * (8 - 8) * -1);
    background-color: bisque;
} /* 0     */

/* 

explain 
Assume the total time to perform anuimation is 30s ( To complete one loop it takes 30s)
and we have 8 items to animate. so, each item will take (30 / 8)s  time

now we want sequantial movement of all elements. so, we add unique delay for each item

we make the value negetive by multiplying it withh -1 
if animation-delay property has negetive value that means some part of animation already completed or you can say already running before you visit the webpage. and after that much animation it will continue 

so this is the logic.

Recap :
Duration : 30 / n
Delay : n - x
negative : -1

where, n = total no. of elements
       x = element index number 

*/

/* We can do it mannually without a mathematical formula but it takes time and not as much efficient / beautiful as using mathematics */

/* Open demostrate.html to understand the logic in better way 
A negetive number control from where tha animation start*/



/* If we don't multiplt with -1
then all items are right of the screem starts one by one coming 
but if we multipy with -1 
then all items are on their positin initially and start moving. which looks good as compare to above 
*/